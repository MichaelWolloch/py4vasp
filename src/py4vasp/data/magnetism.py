from py4vasp.data import _util
import numpy as np
import functools

_step_parameter = """Parameters
----------
steps : int or range
    If present specifies which steps of the simulation should be extracted.
    By default the data of all steps is read.
"""

_index_note = """Notes
-----
The index order is different compared to the raw data when noncollinear calculations
are used. This routine returns the magnetic moments as (steps, atoms, orbitals,
directions)."""

_to_dict_doc = f""" Read the charges and magnetization data into a dictionary.

{_step_parameter}

Returns
-------
dict
    Contains the charges and magnetic moments generated by Vasp projected
    on atoms and orbitals.

{_index_note}
"""

_charges_doc = f""" Read the charges of the selected steps.

{_step_parameter}

Returns
-------
np.ndarray
    Contains the charges for the selected steps projected on atoms and orbitals.
"""

_total_charges_doc = f""" Read the total charges of the selected steps.

{_step_parameter}

Returns
-------
np.ndarray
    Contains the total charges for the selected steps projected on atoms. This
    corresponds to the charges summed over the orbitals.
"""

_moments_doc = f""" Read the magnetic moments of the selected steps.

{_step_parameter}

Returns
-------
np.ndarray
    Contains the magnetic moments for the selected steps projected on atoms and
    orbitals.

{_index_note}
"""

_total_moments_doc = f""" Read the total magnetic moments of the selected steps.

{_step_parameter}

Returns
-------
np.ndarray
    Contains the total magnetic moments for the selected steps projected on atoms.
    This corresponds to the magnetic moments summed over the orbitals.
"""


@_util.add_wrappers
class Magnetism(_util.Data):
    """ The evolution of the magnetization over the simulation.

    This class gives access to the magnetic moments and charges projected on the
    different orbitals on every atom.

    Parameters
    ----------
    raw_magnetism
        Dataclass containing the charges and magnetic moments read from Vasp.
    """

    def __init__(self, raw_magnetism):
        self._raw = raw_magnetism

    @classmethod
    @_util.add_doc(_util.from_file_doc("orbital-resolved magnetic moments"))
    def from_file(cls, file=None):
        return _util.from_file(cls, file, "magnetism")

    def _repr_pretty_(self, p, cycle):
        magmom = "MAGMOM = "
        moments_last_step = self.total_moments(-1)
        moments_to_string = lambda vec: " ".join(f"{moment:.2f}" for moment in vec)
        if moments_last_step is None:
            text = "not available"
        elif moments_last_step.ndim == 1:
            text = magmom + moments_to_string(moments_last_step)
        else:
            separator = " \\\n         "
            generator = (moments_to_string(vec) for vec in moments_last_step)
            text = magmom + separator.join(generator)
        p.text(text)

    @_util.add_doc(_to_dict_doc)
    def to_dict(self, steps=None):
        moments = self.moments(steps)
        moments = {"moments": moments} if moments is not None else {}
        return {"charges": self.charges(steps), **moments}

    @_util.add_doc(_charges_doc)
    def charges(self, steps=None):
        steps = self._default_steps_if_none(steps)
        return self._raw.moments[steps, 0, :, :]

    @_util.add_doc(_moments_doc)
    def moments(self, steps=None):
        steps = self._default_steps_if_none(steps)
        if self._raw.moments.shape[1] == 1:
            return None
        elif self._raw.moments.shape[1] == 2:
            return self._raw.moments[steps, 1, :, :]
        else:
            moments = self._raw.moments[steps, 1:, :, :]
            direction_axis = 1 if moments.ndim == 4 else 0
            return np.moveaxis(moments, direction_axis, -1)

    @_util.add_doc(_total_charges_doc)
    def total_charges(self, steps=None):
        return self._sum_over_orbitals(self.charges(steps))

    @_util.add_doc(_total_moments_doc)
    def total_moments(self, steps=None):
        if self._raw.moments.shape[1] == 1:
            return None
        elif self._raw.moments.shape[1] == 2:
            return self._sum_over_orbitals(self.moments(steps))
        else:
            steps = self._default_steps_if_none(steps)
            total_moments = self._sum_over_orbitals(self._raw.moments[steps, 1:, :, :])
            direction_axis = 1 if total_moments.ndim == 3 else 0
            return np.moveaxis(total_moments, direction_axis, -1)

    def _default_steps_if_none(self, steps):
        return steps if steps is not None else range(len(self._raw.moments))

    def _sum_over_orbitals(self, quantity):
        return np.sum(quantity, axis=-1)
