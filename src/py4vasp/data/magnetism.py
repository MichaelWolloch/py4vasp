from py4vasp.data._base import RefinementDescriptor
import py4vasp.data._trajectory as _trajectory
import py4vasp._util.documentation as _documentation
import py4vasp._util.reader as _reader
import py4vasp.exceptions as exception
import numpy as np
import functools


_index_note = """Notes
-----
The index order is different compared to the raw data when noncollinear calculations
are used. This routine returns the magnetic moments as (steps, atoms, orbitals,
directions)."""


_magnetism_docs = f"""
The magnetic moments and localized charges for selected ionic steps.

This class gives access to the magnetic moments and charges projected on the
different orbitals on every atom.

Parameters
----------
raw_magnetism : RawMagnetism
    Dataclass containing the charges and magnetic moments read from Vasp.

{_trajectory.trajectory_examples("magnetism")}
""".strip()


@_documentation.add(_magnetism_docs)
class Magnetism(_trajectory.DataTrajectory):
    _missing_data_message = "Atom resolved magnetic information not present, please verify LORBIT tag is set."

    to_dict = RefinementDescriptor("_to_dict")
    read = RefinementDescriptor("_to_dict")
    charges = RefinementDescriptor("_charges")
    moments = RefinementDescriptor("_moments")
    total_charges = RefinementDescriptor("_total_charges")
    total_moments = RefinementDescriptor("_total_moments")
    __str__ = RefinementDescriptor("_to_string")

    def _to_string(self):
        magmom = "MAGMOM = "
        moments_last_step = self._total_moments()
        moments_to_string = lambda vec: " ".join(f"{moment:.2f}" for moment in vec)
        if moments_last_step is None:
            return "not spin polarized"
        elif moments_last_step.ndim == 1:
            return magmom + moments_to_string(moments_last_step)
        else:
            separator = " \\\n         "
            generator = (moments_to_string(vec) for vec in moments_last_step)
            return magmom + separator.join(generator)

    @_documentation.add(
        f"""Read the charges and magnetization data into a dictionary.

Returns
-------
dict
    Contains the charges and magnetic moments generated by Vasp projected
    on atoms and orbitals.

{_index_note}"""
    )
    def _to_dict(self):
        return {
            "charges": self._charges(),
            "moments": self._moments(),
        }

    def _charges(self):
        """Read the charges of the selected steps.

        Returns
        -------
        np.ndarray
            Contains the charges for the selected steps projected on atoms and orbitals."""
        moments = _Moments(self._raw_data.moments)
        return moments[self._steps, 0, :, :]

    @_documentation.add(
        f"""Read the magnetic moments of the selected steps.

Returns
-------
np.ndarray
    Contains the magnetic moments for the selected steps projected on atoms and
    orbitals.

{_index_note}"""
    )
    def _moments(self):
        moments = _Moments(self._raw_data.moments)
        _fail_if_steps_out_of_bounds(moments, self._steps)
        if moments.shape[1] == 1:
            return None
        elif moments.shape[1] == 2:
            return moments[self._steps, 1, :, :]
        else:
            moments = moments[self._steps, 1:, :, :]
            direction_axis = 1 if moments.ndim == 4 else 0
            return np.moveaxis(moments, direction_axis, -1)

    def _total_charges(self):
        """Read the total charges of the selected steps.

        Returns
        -------
        np.ndarray
            Contains the total charges for the selected steps projected on atoms. This
            corresponds to the charges summed over the orbitals."""
        return _sum_over_orbitals(self._charges())

    @_documentation.add(
        f"""Read the total magnetic moments of the selected steps.

Returns
-------
np.ndarray
    Contains the total magnetic moments for the selected steps projected on atoms.
    This corresponds to the magnetic moments summed over the orbitals.

{_index_note}"""
    )
    def _total_moments(self):
        moments = _Moments(self._raw_data.moments)
        _fail_if_steps_out_of_bounds(moments, self._steps)
        if moments.shape[1] == 1:
            return None
        elif moments.shape[1] == 2:
            return _sum_over_orbitals(self._moments())
        else:
            total_moments = _sum_over_orbitals(moments[self._steps, 1:, :, :])
            direction_axis = 1 if total_moments.ndim == 3 else 0
            return np.moveaxis(total_moments, direction_axis, -1)


class _Moments(_reader.Reader):
    def error_message(self, key, err):
        key = np.array(key)
        steps = key if key.ndim == 0 else key[0]
        return (
            f"Error reading the magnetic moments. Please check if the steps "
            f"`{steps}` are properly formatted and within the boundaries. "
            "Additionally, you may consider the original error message:\n" + err.args[0]
        )


def _fail_if_steps_out_of_bounds(moments, steps):
    moments[steps]  # try to access requested step raising an error if out of bounds


def _sum_over_orbitals(quantity):
    return np.sum(quantity, axis=-1)
